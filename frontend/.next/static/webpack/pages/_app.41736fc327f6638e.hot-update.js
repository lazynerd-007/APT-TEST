"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/services/authService.ts":
/*!*************************************!*\
  !*** ./src/services/authService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setUpdatePasswordFunction: function() { return /* binding */ setUpdatePasswordFunction; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var _apiClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiClient */ \"./src/services/apiClient.ts\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./src/config.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n\nconst API_ENDPOINT = \"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/auth\");\n// Simulated database of valid users\nconst VALID_USERS = [\n    \"admin@example.com\",\n    \"babsodunewu@gmail.com\",\n    \"employer@bluapt.com\"\n];\n// Store the updatePassword function when it's provided\nlet updatePasswordFn = null;\n// Function to set the updatePassword function from AuthContext\nconst setUpdatePasswordFunction = (fn)=>{\n    updatePasswordFn = fn;\n};\n// Safe access to window object\nconst getWindow = ()=>{\n    return  true ? window : 0;\n};\n// Generate a valid token for Django REST Framework\nconst generateValidToken = (email)=>{\n    // This is still a demo token, but structured to look like a Django REST Framework token\n    // Real tokens would be generated by the backend\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 15);\n    // Format similar to Django REST Framework token (alphanumeric string)\n    return \"\".concat(Buffer.from(email).toString(\"base64\").replace(/=/g, \"\")).concat(random).concat(timestamp % 1000);\n};\nconst authService = {\n    /**\n   * Login with email and password\n   * @param email The user's email\n   * @param password The user's password\n   * @returns Promise with the login result\n   */ login: async (email, password)=>{\n        try {\n            // Try to call the real backend API first\n            try {\n                console.log(\"Attempting to authenticate with backend...\");\n                const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/auth/login/\"), {\n                    email,\n                    password\n                });\n                console.log(\"Backend authentication succeeded:\", response.data);\n                return response.data;\n            } catch (apiError) {\n                console.warn(\"Backend authentication failed, falling back to demo mode:\", apiError);\n                // Fall back to simulated login for development\n                // Simulate API delay\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Check if it's a valid user email (for demo purposes)\n                if (VALID_USERS.includes(email.toLowerCase())) {\n                    console.log(\"Demo login successful for \".concat(email));\n                    // Generate a token in a format similar to what Django REST Framework would produce\n                    const token = generateValidToken(email);\n                    // Return user info\n                    return {\n                        token,\n                        user: {\n                            email,\n                            name: email.split(\"@\")[0],\n                            role: email.includes(\"admin\") ? \"admin\" : \"employer\"\n                        }\n                    };\n                } else {\n                    throw new Error(\"Invalid email or password\");\n                }\n            }\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    },\n    /**\n   * Request a password reset email\n   * @param email The user's email address\n   * @returns Promise with the request result\n   */ requestPasswordReset: async (email)=>{\n        try {\n            // In a real implementation, this would call the backend API\n            // For demo purposes, we'll simulate a successful response\n            // Simulate API delay\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            // Check if it's a valid user email (for demo purposes)\n            if (VALID_USERS.includes(email.toLowerCase())) {\n                console.log(\"Password reset requested for \".concat(email, \". In a real app, an email would be sent.\"));\n                // In a real implementation, this would send an actual email\n                // For demo purposes, we'll just log the reset link to the console\n                const resetToken = Buffer.from(email + Date.now()).toString(\"base64\");\n                const win = getWindow();\n                const resetLink = win ? \"\".concat(win.location.origin, \"/reset-password?token=\").concat(resetToken) : \"/reset-password?token=\".concat(resetToken);\n                console.log(\"Reset link:\", resetLink);\n                console.log(\"Please use this link to reset your password (demo only)\");\n                return {\n                    success: true,\n                    message: \"If your email exists in our system, you will receive password reset instructions shortly. Please check your email and spam folder.\"\n                };\n            } else {\n                // For security reasons, don't reveal that the email doesn't exist\n                console.log(\"Password reset requested for non-existent user: \".concat(email));\n                return {\n                    success: true,\n                    message: \"If your email exists in our system, you will receive password reset instructions shortly. Please check your email and spam folder.\"\n                };\n            }\n        // Real implementation would be:\n        // const response = await apiClient.post(`/auth/reset-password/request`, { email });\n        // return response.data;\n        } catch (error) {\n            if (axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isAxiosError(error) && error.response) {\n                throw new Error(error.response.data.error || \"Failed to request password reset\");\n            }\n            throw new Error(\"Network error occurred\");\n        }\n    },\n    /**\n   * Reset password with token\n   * @param token The reset token from the email\n   * @param newPassword The new password\n   * @returns Promise with the reset result\n   */ resetPassword: async (token, newPassword)=>{\n        try {\n            // In a real implementation, this would call the backend API\n            // For demo purposes, we'll simulate a successful response\n            // Simulate API delay\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            // Decode the token to get the email (in a real app, this would be more secure)\n            try {\n                const decodedData = Buffer.from(token, \"base64\").toString();\n                const email = decodedData.split(new RegExp(\"[0-9]\"))[0]; // Extract email part\n                // Verify the email is valid\n                if (VALID_USERS.includes(email.toLowerCase())) {\n                    // Update the password using the function from AuthContext\n                    if (updatePasswordFn) {\n                        const updated = await updatePasswordFn(email, newPassword);\n                        if (updated) {\n                            return {\n                                success: true,\n                                message: \"Password has been successfully reset. You can now log in with your new password.\"\n                            };\n                        } else {\n                            return {\n                                success: false,\n                                message: \"Failed to update password. Please try again.\"\n                            };\n                        }\n                    } else {\n                        console.error(\"updatePasswordFn is not set\");\n                        return {\n                            success: false,\n                            message: \"System error: Password update function not available.\"\n                        };\n                    }\n                } else {\n                    return {\n                        success: false,\n                        message: \"Invalid or expired token\"\n                    };\n                }\n            } catch (e) {\n                return {\n                    success: false,\n                    message: \"Invalid or expired token\"\n                };\n            }\n        // Real implementation would be:\n        // const response = await apiClient.post(`/auth/reset-password/confirm`, { token, new_password: newPassword });\n        // return response.data;\n        } catch (error) {\n            if (axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isAxiosError(error) && error.response) {\n                throw new Error(error.response.data.error || \"Failed to reset password\");\n            }\n            throw new Error(\"Network error occurred\");\n        }\n    },\n    /**\n   * Test authentication\n   * @returns Promise with the test result\n   */ testAuth: async ()=>{\n        try {\n            const response = await _apiClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"/users/test_auth/\");\n            console.log(\"Authentication test successful:\", response.data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Authentication test failed:\", error);\n            throw error;\n        }\n    },\n    // Login user\n    loginUser: async (credentials)=>{\n        try {\n            console.log(\"Attempting to login with credentials:\", credentials);\n            const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/auth/login/\"), credentials);\n            console.log(\"Login response:\", response.data);\n            const user = response.data;\n            // Store user in localStorage\n            localStorage.setItem(\"user\", JSON.stringify(user));\n            return user;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    },\n    // Register user\n    registerUser: async (data)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/users/register/\"), data);\n            return response.data;\n        } catch (error) {\n            console.error(\"Registration error:\", error);\n            throw error;\n        }\n    },\n    // Logout user\n    logout: ()=>{\n        localStorage.removeItem(\"user\");\n    },\n    // Get current user from localStorage\n    getCurrentUser: ()=>{\n        const userStr = localStorage.getItem(\"user\");\n        if (userStr) {\n            return JSON.parse(userStr);\n        }\n        return null;\n    },\n    // Login as demo user\n    loginAsDemo: async ()=>{\n        try {\n            // Use the demo credentials directly\n            const loginCredentials = {\n                email: \"demo.candidate@example.com\",\n                password: \"demopassword\"\n            };\n            console.log(\"Attempting demo login with credentials:\", loginCredentials);\n            // Try to login with the demo credentials\n            try {\n                const loginResponse = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/auth/login/\"), loginCredentials);\n                console.log(\"Demo login successful:\", loginResponse.data);\n                const user = loginResponse.data;\n                // Store user in localStorage\n                localStorage.setItem(\"user\", JSON.stringify(user));\n                return user;\n            } catch (loginError) {\n                // If login fails, try to create the demo user first\n                console.log(\"Demo login failed:\", loginError);\n                console.log(\"Trying to create demo user first...\");\n                const createResponse = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/users/create_demo_user/\"));\n                console.log(\"Demo user creation response:\", createResponse.data);\n                // Then try to login again\n                console.log(\"Attempting demo login again after user creation...\");\n                const loginResponse = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(_config__WEBPACK_IMPORTED_MODULE_1__.API_URL, \"/auth/login/\"), loginCredentials);\n                console.log(\"Demo login successful after user creation:\", loginResponse.data);\n                const user = loginResponse.data;\n                // Store user in localStorage\n                localStorage.setItem(\"user\", JSON.stringify(user));\n                return user;\n            }\n        } catch (error) {\n            console.error(\"Demo login error:\", error);\n            if (axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isAxiosError(error) && error.response) {\n                console.error(\"Error response data:\", error.response.data);\n                console.error(\"Error response status:\", error.response.status);\n            }\n            throw error;\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (authService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dGhTZXJ2aWNlLnRzPzRkYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBhcGlDbGllbnQgZnJvbSAnLi9hcGlDbGllbnQnO1xuaW1wb3J0IHsgQVBJX1VSTCB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IEFQSV9FTkRQT0lOVCA9IGAke0FQSV9VUkx9L2F1dGhgO1xuXG4vLyBTaW11bGF0ZWQgZGF0YWJhc2Ugb2YgdmFsaWQgdXNlcnNcbmNvbnN0IFZBTElEX1VTRVJTID0gW1xuICAnYWRtaW5AZXhhbXBsZS5jb20nLFxuICAnYmFic29kdW5ld3VAZ21haWwuY29tJyxcbiAgJ2VtcGxveWVyQGJsdWFwdC5jb20nXG5dO1xuXG4vLyBTdG9yZSB0aGUgdXBkYXRlUGFzc3dvcmQgZnVuY3Rpb24gd2hlbiBpdCdzIHByb3ZpZGVkXG5sZXQgdXBkYXRlUGFzc3dvcmRGbjogKChlbWFpbDogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+KSB8IG51bGwgPSBudWxsO1xuXG4vLyBGdW5jdGlvbiB0byBzZXQgdGhlIHVwZGF0ZVBhc3N3b3JkIGZ1bmN0aW9uIGZyb20gQXV0aENvbnRleHRcbmV4cG9ydCBjb25zdCBzZXRVcGRhdGVQYXNzd29yZEZ1bmN0aW9uID0gKGZuOiAoZW1haWw6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPikgPT4ge1xuICB1cGRhdGVQYXNzd29yZEZuID0gZm47XG59O1xuXG4vLyBTYWZlIGFjY2VzcyB0byB3aW5kb3cgb2JqZWN0XG5jb25zdCBnZXRXaW5kb3cgPSAoKSA9PiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGw7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHZhbGlkIHRva2VuIGZvciBEamFuZ28gUkVTVCBGcmFtZXdvcmtcbmNvbnN0IGdlbmVyYXRlVmFsaWRUb2tlbiA9IChlbWFpbDogc3RyaW5nKSA9PiB7XG4gIC8vIFRoaXMgaXMgc3RpbGwgYSBkZW1vIHRva2VuLCBidXQgc3RydWN0dXJlZCB0byBsb29rIGxpa2UgYSBEamFuZ28gUkVTVCBGcmFtZXdvcmsgdG9rZW5cbiAgLy8gUmVhbCB0b2tlbnMgd291bGQgYmUgZ2VuZXJhdGVkIGJ5IHRoZSBiYWNrZW5kXG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gIFxuICAvLyBGb3JtYXQgc2ltaWxhciB0byBEamFuZ28gUkVTVCBGcmFtZXdvcmsgdG9rZW4gKGFscGhhbnVtZXJpYyBzdHJpbmcpXG4gIHJldHVybiBgJHtCdWZmZXIuZnJvbShlbWFpbCkudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoLz0vZywgJycpfSR7cmFuZG9tfSR7dGltZXN0YW1wICUgMTAwMH1gO1xufTtcblxuLy8gRGVmaW5lIHVzZXIgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBmaXJzdF9uYW1lOiBzdHJpbmc7XG4gIGxhc3RfbmFtZTogc3RyaW5nO1xuICByb2xlOiBzdHJpbmc7XG4gIHRva2VuPzogc3RyaW5nO1xufVxuXG4vLyBEZWZpbmUgbG9naW4gY3JlZGVudGlhbHMgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIExvZ2luQ3JlZGVudGlhbHMge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xufVxuXG4vLyBEZWZpbmUgcmVnaXN0cmF0aW9uIGRhdGEgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFJlZ2lzdHJhdGlvbkRhdGEge1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBmaXJzdF9uYW1lOiBzdHJpbmc7XG4gIGxhc3RfbmFtZTogc3RyaW5nO1xuICByb2xlOiBzdHJpbmc7XG59XG5cbmNvbnN0IGF1dGhTZXJ2aWNlID0ge1xuICAvKipcbiAgICogTG9naW4gd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmRcbiAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWxcbiAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSBsb2dpbiByZXN1bHRcbiAgICovXG4gIGxvZ2luOiBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8eyB0b2tlbjogc3RyaW5nOyB1c2VyOiBhbnkgfT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gY2FsbCB0aGUgcmVhbCBiYWNrZW5kIEFQSSBmaXJzdFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gYXV0aGVudGljYXRlIHdpdGggYmFja2VuZC4uLicpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vYXV0aC9sb2dpbi9gLCB7XG4gICAgICAgICAgZW1haWwsXG4gICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnQmFja2VuZCBhdXRoZW50aWNhdGlvbiBzdWNjZWVkZWQ6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBjYXRjaCAoYXBpRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCYWNrZW5kIGF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGRlbW8gbW9kZTonLCBhcGlFcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gc2ltdWxhdGVkIGxvZ2luIGZvciBkZXZlbG9wbWVudFxuICAgICAgICAvLyBTaW11bGF0ZSBBUEkgZGVsYXlcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIHVzZXIgZW1haWwgKGZvciBkZW1vIHB1cnBvc2VzKVxuICAgICAgICBpZiAoVkFMSURfVVNFUlMuaW5jbHVkZXMoZW1haWwudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRGVtbyBsb2dpbiBzdWNjZXNzZnVsIGZvciAke2VtYWlsfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIGEgdG9rZW4gaW4gYSBmb3JtYXQgc2ltaWxhciB0byB3aGF0IERqYW5nbyBSRVNUIEZyYW1ld29yayB3b3VsZCBwcm9kdWNlXG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBnZW5lcmF0ZVZhbGlkVG9rZW4oZW1haWwpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJldHVybiB1c2VyIGluZm9cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICBuYW1lOiBlbWFpbC5zcGxpdCgnQCcpWzBdLFxuICAgICAgICAgICAgICByb2xlOiBlbWFpbC5pbmNsdWRlcygnYWRtaW4nKSA/ICdhZG1pbicgOiAnZW1wbG95ZXInXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYSBwYXNzd29yZCByZXNldCBlbWFpbFxuICAgKiBAcGFyYW0gZW1haWwgVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgcmVxdWVzdCByZXN1bHRcbiAgICovXG4gIHJlcXVlc3RQYXNzd29yZFJlc2V0OiBhc3luYyAoZW1haWw6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgY2FsbCB0aGUgYmFja2VuZCBBUElcbiAgICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCB3ZSdsbCBzaW11bGF0ZSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgQVBJIGRlbGF5XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgdmFsaWQgdXNlciBlbWFpbCAoZm9yIGRlbW8gcHVycG9zZXMpXG4gICAgICBpZiAoVkFMSURfVVNFUlMuaW5jbHVkZXMoZW1haWwudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBhc3N3b3JkIHJlc2V0IHJlcXVlc3RlZCBmb3IgJHtlbWFpbH0uIEluIGEgcmVhbCBhcHAsIGFuIGVtYWlsIHdvdWxkIGJlIHNlbnQuYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgc2VuZCBhbiBhY3R1YWwgZW1haWxcbiAgICAgICAgLy8gRm9yIGRlbW8gcHVycG9zZXMsIHdlJ2xsIGp1c3QgbG9nIHRoZSByZXNldCBsaW5rIHRvIHRoZSBjb25zb2xlXG4gICAgICAgIGNvbnN0IHJlc2V0VG9rZW4gPSBCdWZmZXIuZnJvbShlbWFpbCArIERhdGUubm93KCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgY29uc3Qgd2luID0gZ2V0V2luZG93KCk7XG4gICAgICAgIGNvbnN0IHJlc2V0TGluayA9IHdpbiA/IGAke3dpbi5sb2NhdGlvbi5vcmlnaW59L3Jlc2V0LXBhc3N3b3JkP3Rva2VuPSR7cmVzZXRUb2tlbn1gIDogYC9yZXNldC1wYXNzd29yZD90b2tlbj0ke3Jlc2V0VG9rZW59YDtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXNldCBsaW5rOicsIHJlc2V0TGluayk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQbGVhc2UgdXNlIHRoaXMgbGluayB0byByZXNldCB5b3VyIHBhc3N3b3JkIChkZW1vIG9ubHkpJyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZTogJ0lmIHlvdXIgZW1haWwgZXhpc3RzIGluIG91ciBzeXN0ZW0sIHlvdSB3aWxsIHJlY2VpdmUgcGFzc3dvcmQgcmVzZXQgaW5zdHJ1Y3Rpb25zIHNob3J0bHkuIFBsZWFzZSBjaGVjayB5b3VyIGVtYWlsIGFuZCBzcGFtIGZvbGRlci4nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igc2VjdXJpdHkgcmVhc29ucywgZG9uJ3QgcmV2ZWFsIHRoYXQgdGhlIGVtYWlsIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgY29uc29sZS5sb2coYFBhc3N3b3JkIHJlc2V0IHJlcXVlc3RlZCBmb3Igbm9uLWV4aXN0ZW50IHVzZXI6ICR7ZW1haWx9YCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsIC8vIFN0aWxsIHJldHVybiBzdWNjZXNzIGZvciBzZWN1cml0eVxuICAgICAgICAgIG1lc3NhZ2U6ICdJZiB5b3VyIGVtYWlsIGV4aXN0cyBpbiBvdXIgc3lzdGVtLCB5b3Ugd2lsbCByZWNlaXZlIHBhc3N3b3JkIHJlc2V0IGluc3RydWN0aW9ucyBzaG9ydGx5LiBQbGVhc2UgY2hlY2sgeW91ciBlbWFpbCBhbmQgc3BhbSBmb2xkZXIuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZWFsIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlOlxuICAgICAgLy8gY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChgL2F1dGgvcmVzZXQtcGFzc3dvcmQvcmVxdWVzdGAsIHsgZW1haWwgfSk7XG4gICAgICAvLyByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGF4aW9zLmlzQXhpb3NFcnJvcihlcnJvcikgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byByZXF1ZXN0IHBhc3N3b3JkIHJlc2V0Jyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3Igb2NjdXJyZWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0IHBhc3N3b3JkIHdpdGggdG9rZW5cbiAgICogQHBhcmFtIHRva2VuIFRoZSByZXNldCB0b2tlbiBmcm9tIHRoZSBlbWFpbFxuICAgKiBAcGFyYW0gbmV3UGFzc3dvcmQgVGhlIG5ldyBwYXNzd29yZFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHJlc2V0IHJlc3VsdFxuICAgKi9cbiAgcmVzZXRQYXNzd29yZDogYXN5bmMgKHRva2VuOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nIH0+ID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGNhbGwgdGhlIGJhY2tlbmQgQVBJXG4gICAgICAvLyBGb3IgZGVtbyBwdXJwb3Nlcywgd2UnbGwgc2ltdWxhdGUgYSBzdWNjZXNzZnVsIHJlc3BvbnNlXG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIEFQSSBkZWxheVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgIFxuICAgICAgLy8gRGVjb2RlIHRoZSB0b2tlbiB0byBnZXQgdGhlIGVtYWlsIChpbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIG1vcmUgc2VjdXJlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZERhdGEgPSBCdWZmZXIuZnJvbSh0b2tlbiwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gZGVjb2RlZERhdGEuc3BsaXQobmV3IFJlZ0V4cCgnWzAtOV0nKSlbMF07IC8vIEV4dHJhY3QgZW1haWwgcGFydFxuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IHRoZSBlbWFpbCBpcyB2YWxpZFxuICAgICAgICBpZiAoVkFMSURfVVNFUlMuaW5jbHVkZXMoZW1haWwudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBhc3N3b3JkIHVzaW5nIHRoZSBmdW5jdGlvbiBmcm9tIEF1dGhDb250ZXh0XG4gICAgICAgICAgaWYgKHVwZGF0ZVBhc3N3b3JkRm4pIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCB1cGRhdGVQYXNzd29yZEZuKGVtYWlsLCBuZXdQYXNzd29yZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUGFzc3dvcmQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHJlc2V0LiBZb3UgY2FuIG5vdyBsb2cgaW4gd2l0aCB5b3VyIG5ldyBwYXNzd29yZC4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gdXBkYXRlIHBhc3N3b3JkLiBQbGVhc2UgdHJ5IGFnYWluLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigndXBkYXRlUGFzc3dvcmRGbiBpcyBub3Qgc2V0Jyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1N5c3RlbSBlcnJvcjogUGFzc3dvcmQgdXBkYXRlIGZ1bmN0aW9uIG5vdCBhdmFpbGFibGUuJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgb3IgZXhwaXJlZCB0b2tlbidcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgb3IgZXhwaXJlZCB0b2tlbidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVhbCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBiZTpcbiAgICAgIC8vIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoYC9hdXRoL3Jlc2V0LXBhc3N3b3JkL2NvbmZpcm1gLCB7IHRva2VuLCBuZXdfcGFzc3dvcmQ6IG5ld1Bhc3N3b3JkIH0pO1xuICAgICAgLy8gcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChheGlvcy5pc0F4aW9zRXJyb3IoZXJyb3IpICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gcmVzZXQgcGFzc3dvcmQnKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBlcnJvciBvY2N1cnJlZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGVzdCBhdXRoZW50aWNhdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHRlc3QgcmVzdWx0XG4gICAqL1xuICB0ZXN0QXV0aDogYXN5bmMgKCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldCgnL3VzZXJzL3Rlc3RfYXV0aC8nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBdXRoZW50aWNhdGlvbiB0ZXN0IHN1Y2Nlc3NmdWw6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQXV0aGVudGljYXRpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8vIExvZ2luIHVzZXJcbiAgbG9naW5Vc2VyOiBhc3luYyAoY3JlZGVudGlhbHM6IExvZ2luQ3JlZGVudGlhbHMpOiBQcm9taXNlPFVzZXI+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gbG9naW4gd2l0aCBjcmVkZW50aWFsczonLCBjcmVkZW50aWFscyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vYXV0aC9sb2dpbi9gLCBjcmVkZW50aWFscyk7XG4gICAgICBjb25zb2xlLmxvZygnTG9naW4gcmVzcG9uc2U6JywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICBjb25zdCB1c2VyID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdXNlciBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyJywgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgICAgXG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuICBcbiAgLy8gUmVnaXN0ZXIgdXNlclxuICByZWdpc3RlclVzZXI6IGFzeW5jIChkYXRhOiBSZWdpc3RyYXRpb25EYXRhKTogUHJvbWlzZTxVc2VyPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS91c2Vycy9yZWdpc3Rlci9gLCBkYXRhKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSZWdpc3RyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuICBcbiAgLy8gTG9nb3V0IHVzZXJcbiAgbG9nb3V0OiAoKTogdm9pZCA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXInKTtcbiAgfSxcbiAgXG4gIC8vIEdldCBjdXJyZW50IHVzZXIgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgZ2V0Q3VycmVudFVzZXI6ICgpOiBVc2VyIHwgbnVsbCA9PiB7XG4gICAgY29uc3QgdXNlclN0ciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VyJyk7XG4gICAgaWYgKHVzZXJTdHIpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHVzZXJTdHIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgXG4gIC8vIExvZ2luIGFzIGRlbW8gdXNlclxuICBsb2dpbkFzRGVtbzogYXN5bmMgKCk6IFByb21pc2U8VXNlcj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgdGhlIGRlbW8gY3JlZGVudGlhbHMgZGlyZWN0bHlcbiAgICAgIGNvbnN0IGxvZ2luQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgIGVtYWlsOiAnZGVtby5jYW5kaWRhdGVAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZDogJ2RlbW9wYXNzd29yZCdcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIGRlbW8gbG9naW4gd2l0aCBjcmVkZW50aWFsczonLCBsb2dpbkNyZWRlbnRpYWxzKTtcbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIGxvZ2luIHdpdGggdGhlIGRlbW8gY3JlZGVudGlhbHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxvZ2luUmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L2F1dGgvbG9naW4vYCwgbG9naW5DcmVkZW50aWFscyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEZW1vIGxvZ2luIHN1Y2Nlc3NmdWw6JywgbG9naW5SZXNwb25zZS5kYXRhKTtcbiAgICAgICAgY29uc3QgdXNlciA9IGxvZ2luUmVzcG9uc2UuZGF0YTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHVzZXIgaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyJywgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICB9IGNhdGNoIChsb2dpbkVycm9yKSB7XG4gICAgICAgIC8vIElmIGxvZ2luIGZhaWxzLCB0cnkgdG8gY3JlYXRlIHRoZSBkZW1vIHVzZXIgZmlyc3RcbiAgICAgICAgY29uc29sZS5sb2coJ0RlbW8gbG9naW4gZmFpbGVkOicsIGxvZ2luRXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHRvIGNyZWF0ZSBkZW1vIHVzZXIgZmlyc3QuLi4nKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS91c2Vycy9jcmVhdGVfZGVtb191c2VyL2ApO1xuICAgICAgICBjb25zb2xlLmxvZygnRGVtbyB1c2VyIGNyZWF0aW9uIHJlc3BvbnNlOicsIGNyZWF0ZVJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhlbiB0cnkgdG8gbG9naW4gYWdhaW5cbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgZGVtbyBsb2dpbiBhZ2FpbiBhZnRlciB1c2VyIGNyZWF0aW9uLi4uJyk7XG4gICAgICAgIGNvbnN0IGxvZ2luUmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L2F1dGgvbG9naW4vYCwgbG9naW5DcmVkZW50aWFscyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEZW1vIGxvZ2luIHN1Y2Nlc3NmdWwgYWZ0ZXIgdXNlciBjcmVhdGlvbjonLCBsb2dpblJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBjb25zdCB1c2VyID0gbG9naW5SZXNwb25zZS5kYXRhO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgdXNlciBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXInLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRGVtbyBsb2dpbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICBpZiAoYXhpb3MuaXNBeGlvc0Vycm9yKGVycm9yKSAmJiBlcnJvci5yZXNwb25zZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBkYXRhOicsIGVycm9yLnJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBzdGF0dXM6JywgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXV0aFNlcnZpY2U7ICJdLCJuYW1lcyI6WyJheGlvcyIsImFwaUNsaWVudCIsIkFQSV9VUkwiLCJBUElfRU5EUE9JTlQiLCJWQUxJRF9VU0VSUyIsInVwZGF0ZVBhc3N3b3JkRm4iLCJzZXRVcGRhdGVQYXNzd29yZEZ1bmN0aW9uIiwiZm4iLCJnZXRXaW5kb3ciLCJ3aW5kb3ciLCJnZW5lcmF0ZVZhbGlkVG9rZW4iLCJlbWFpbCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJNYXRoIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJCdWZmZXIiLCJmcm9tIiwicmVwbGFjZSIsImF1dGhTZXJ2aWNlIiwibG9naW4iLCJwYXNzd29yZCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsInBvc3QiLCJkYXRhIiwiYXBpRXJyb3IiLCJ3YXJuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaW5jbHVkZXMiLCJ0b0xvd2VyQ2FzZSIsInRva2VuIiwidXNlciIsIm5hbWUiLCJzcGxpdCIsInJvbGUiLCJFcnJvciIsImVycm9yIiwicmVxdWVzdFBhc3N3b3JkUmVzZXQiLCJyZXNldFRva2VuIiwid2luIiwicmVzZXRMaW5rIiwibG9jYXRpb24iLCJvcmlnaW4iLCJzdWNjZXNzIiwibWVzc2FnZSIsImlzQXhpb3NFcnJvciIsInJlc2V0UGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsImRlY29kZWREYXRhIiwiUmVnRXhwIiwidXBkYXRlZCIsImUiLCJ0ZXN0QXV0aCIsImdldCIsImxvZ2luVXNlciIsImNyZWRlbnRpYWxzIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWdpc3RlclVzZXIiLCJsb2dvdXQiLCJyZW1vdmVJdGVtIiwiZ2V0Q3VycmVudFVzZXIiLCJ1c2VyU3RyIiwiZ2V0SXRlbSIsInBhcnNlIiwibG9naW5Bc0RlbW8iLCJsb2dpbkNyZWRlbnRpYWxzIiwibG9naW5SZXNwb25zZSIsImxvZ2luRXJyb3IiLCJjcmVhdGVSZXNwb25zZSIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/services/authService.ts\n"));

/***/ })

});